# 算法解析

----

## 树结构

### Leetcode §129 计算树结构代表的数字总和

https://leetcode.com/problems/sum-root-to-leaf-numbers/

#### 需求概述

给定一个树结构,每个节点的值都限定在0-9
假设从根节点到一个叶节点,其路径上的节点数值为1->2->3,相当于数值123
现在需要计算这个树的所有根节点到叶节点的路径所代表数值之和

#### 计算逻辑与代码

##### 深度优先遍历

从树结构的根节点出发,使用递归方式向下访问子节点
递归调用时,将当前节点的值与上一层传入的值相加,并乘以10,作为下一层节点的基数
这样当访问到叶节点的时候,就可以获得从根节点开始的总数值
将所有的数值累加即可

#### 代码

`../src/Leetcode/SumRootToLeafNumbers_129.cs`

#### 测试用例

`../src/LeetcodeTest/SumRootToLeafNumbersTest.cs`

1. 根节点为Null
2. 仅包含一个节点的树
3. 包含子节点的树(二层,三层)
4. 仅包含左子节点的树
5. 不平衡的二叉树
6. 叶节点为0的树(针对自下而上的计算方法特别增加的用例,如果采用自上而下的方法,不需要此用例)

### Leetcode §144 前序遍历树结构

https://leetcode.com/problems/binary-tree-preorder-traversal/

#### 需求概述

给定一个树结构,其中每个节点都包含一个`Int`类型的值,以及对左右子节点的引用
要求使用前序遍历处理树结构,并用`IList<int>`类型输出结果
*前序遍历:对于一个树结构中的节点,首先访问节点本身,然后分别访问左子树和右子树*

#### 计算逻辑与代码

##### 使用递归

对于一棵树(包括子树),首先访问根节点,然后分别遍历左右节点,结果全部输出到同一个数组中,即可达到前序遍历的效果

**评价:**
正常来说看到树相关的算法,第一想到的就是递归解法
递归本身效率比较高(仅需要付出函数调用的开销即可),而且符合抽象上的逻辑
唯一需要注意的是递归的层数,极端情况下可能出现栈溢出异常

##### 使用堆栈+循环

对于一棵树(包括子树),首先访问根节点,然后将右节点和左节点分别推入栈中
然后开启循环,当栈不为空时,弹出最顶层的节点,访问其值,然后查看此节点是否有子节点,如果有子节点,继续按照先右节点后左节点的顺序入栈
循环直到栈中所有节点都弹出即可
*由于题目要求前序遍历,应当按照根节点-左子节点-右子节点的顺序处理,所以入栈的时候需要先推入右子节点,然后再推入左子节点,出栈的时候也会对应地先弹出左子节点进行处理*

**评价:**
使用堆栈的解法相比于递归解法没有那么直观,而且效率也不一定更高,但是不会出现程序栈溢出的异常
很多时候面试官会更喜欢用这种方式考察代码,主要是考察面试人思维能否快速转换

#### 代码

`../src/Leetcode/Binary_Tree_Preorder_Traversal_144.cs`

#### 测试用例

`../src/LeetcodeTest/BinaryTreePreorderTraversalTest.cs`

1. 根节点为空
2. 树结构仅包含根节点
3. 一个二层的树,包含少数几个节点(左右都有)
4. 一个三层的树,仅包含左/右子节点
5. 一个完全二叉树

### Leetcode §145 后序遍历树结构

https://leetcode.com/problems/binary-tree-postorder-traversal
*基本逻辑与§144一致,不需赘述*

#### 计算逻辑

##### 递归

同§144,调整添加到列表的先后顺序即可

##### 循环

从§144的例子中,循环可以用来代替递归
问题在于,后序遍历的循环,如果完全按照前序遍历的方式来做,会比较麻烦
因为我们遍历一棵子树,总是从根节点入手的:**根节点最先被访问,但是其值在最后才被加入结果,如果我们将根节点也推入堆栈,那么就需要额外标记,当下一次堆栈弹出根节点时,我们就不能将其左右子节点再次加入堆栈,否则将导致死循环**
所以,我考虑保持前序遍历的访问方式,但是按照**记录根节点数值->访问右子节点->访问左子节点**顺序(也就是正常访问顺序的镜像)处理.当我们完成遍历后,调用IList.Reverse()方法,将结果镜像,实际的访问顺序就变成了**访问左子节点->访问右子节点->记录根节点数值**,也就是后序遍历
