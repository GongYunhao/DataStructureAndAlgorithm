# 算法解析

----

## 树结构

### Leetcode §124 二叉树中的最大路径和

https://leetcode.com/problems/binary-tree-maximum-path-sum
https://leetcode-cn.com/problems/binary-tree-maximum-path-sum

#### 需求概述

给定一个非空二叉树，返回其最大路径和。
本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。

#### 计算逻辑

对于二叉树结构,最为直观的访问方式就是递归,用在这一题中也是十分合适的
首先就要提取出树的最小子结构,如下图所示

```mermaid
graph TD
parent((1.父节点)) --- start((2.根节点))
start --- leftChild((3.左子树))
start --- rightChild((4.右子树))
```

图中展示了一个树的最小子结构,包含了父节点,子树根节点,根节点的左右子树四个基本元素,在这个基础上讨论题目的解法

回到题目本身,题目要求计算树节点的最大路径和,对于上图展示的结构,我们所需要寻找的目标路径有以下几种可能性:

1. 目标路径**仅**存在于左子树(节点1)或右子树(节点2)内部
2. 目标路径从左/右子树出发,经过根节点(当前层级无法判断是否通向父节点:这需要通过递归返回值,在上一层程序中判断)
3. 目标从左子树出发,经过根节点,通向右子树(当然方向可以反过来,从右子树出发,但是结果是一样的)

那么答案就相当明显了,我们可以先分别计算左右子树内部最大的路径和,然后结合根节点的值判断各种可能性,并保留最大值
需要注意的是,针对**可能性2**,应当将本层级的最大路径和数值返回给上一层,让父节点判断是否使用返回值

#### 代码

`../src/Leetcode/BinaryTreeMaximumPathSum_124.cs`

#### 测试用例

`../src/LeetcodeTest/BinaryTreeMaximumPathSumTest.cs`

1. 仅包含一个节点的树:
   正数,负数,0,int类型的最大最小值
2. 目标路径限定在子树内部
3. 目标路径包括子树和根节点
4. 目标路径包括子树,根节点与父节点
5. 目标路径包括左子树,根节点,右子树

### Leetcode §129 计算树结构代表的数字总和

https://leetcode.com/problems/sum-root-to-leaf-numbers/

#### 需求概述

给定一个树结构,每个节点的值都限定在0-9
假设从根节点到一个叶节点,其路径上的节点数值为1->2->3,相当于数值123
现在需要计算这个树的所有根节点到叶节点的路径所代表数值之和

#### 计算逻辑与代码

##### 深度优先遍历

从树结构的根节点出发,使用递归方式向下访问子节点
递归调用时,将当前节点的值与上一层传入的值相加,并乘以10,作为下一层节点的基数
这样当访问到叶节点的时候,就可以获得从根节点开始的总数值
将所有的数值累加即可

#### 代码

`../src/Leetcode/SumRootToLeafNumbers_129.cs`

#### 测试用例

`../src/LeetcodeTest/SumRootToLeafNumbersTest.cs`

1. 根节点为Null
2. 仅包含一个节点的树
3. 包含子节点的树(二层,三层)
4. 仅包含左子节点的树
5. 不平衡的二叉树
6. 叶节点为0的树(针对自下而上的计算方法特别增加的用例,如果采用自上而下的方法,不需要此用例)

### Leetcode §144 前序遍历树结构

https://leetcode.com/problems/binary-tree-preorder-traversal/

#### 需求概述

给定一个树结构,其中每个节点都包含一个`Int`类型的值,以及对左右子节点的引用
要求使用前序遍历处理树结构,并用`IList<int>`类型输出结果
*前序遍历:对于一个树结构中的节点,首先访问节点本身,然后分别访问左子树和右子树*

#### 计算逻辑与代码

##### 使用递归

对于一棵树(包括子树),首先访问根节点,然后分别遍历左右节点,结果全部输出到同一个数组中,即可达到前序遍历的效果

**评价:**
正常来说看到树相关的算法,第一想到的就是递归解法
递归本身效率比较高(仅需要付出函数调用的开销即可),而且符合抽象上的逻辑
唯一需要注意的是递归的层数,极端情况下可能出现栈溢出异常

##### 使用堆栈+循环

对于一棵树(包括子树),首先访问根节点,然后将右节点和左节点分别推入栈中
然后开启循环,当栈不为空时,弹出最顶层的节点,访问其值,然后查看此节点是否有子节点,如果有子节点,继续按照先右节点后左节点的顺序入栈
循环直到栈中所有节点都弹出即可
*由于题目要求前序遍历,应当按照根节点-左子节点-右子节点的顺序处理,所以入栈的时候需要先推入右子节点,然后再推入左子节点,出栈的时候也会对应地先弹出左子节点进行处理*

**评价:**
使用堆栈的解法相比于递归解法没有那么直观,而且效率也不一定更高,但是不会出现程序栈溢出的异常
很多时候面试官会更喜欢用这种方式考察代码,主要是考察面试人思维能否快速转换

#### 代码

`../src/Leetcode/Binary_Tree_Preorder_Traversal_144.cs`

#### 测试用例

`../src/LeetcodeTest/BinaryTreePreorderTraversalTest.cs`

1. 根节点为空
2. 树结构仅包含根节点
3. 一个二层的树,包含少数几个节点(左右都有)
4. 一个三层的树,仅包含左/右子节点
5. 一个完全二叉树

### Leetcode §145 后序遍历树结构

https://leetcode.com/problems/binary-tree-postorder-traversal
*基本逻辑与§144一致,不需赘述*

#### 计算逻辑

##### 递归

同§144,调整添加到列表的先后顺序即可

##### 循环

从§144的例子中,循环可以用来代替递归
问题在于,后序遍历的循环,如果完全按照前序遍历的方式来做,会比较麻烦
因为我们遍历一棵子树,总是从根节点入手的:**根节点最先被访问,但是其值在最后才被加入结果,如果我们将根节点也推入堆栈,那么就需要额外标记,当下一次堆栈弹出根节点时,我们就不能将其左右子节点再次加入堆栈,否则将导致死循环**
所以,我考虑保持前序遍历的访问方式,但是按照**记录根节点数值->访问右子节点->访问左子节点**顺序(也就是正常访问顺序的镜像)处理.当我们完成遍历后,调用IList.Reverse()方法,将结果镜像,实际的访问顺序就变成了**访问左子节点->访问右子节点->记录根节点数值**,也就是后序遍历
