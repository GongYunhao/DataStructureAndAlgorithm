# 算法解析

----

## Leetcode §114 前序遍历树结构

https://leetcode.com/problems/binary-tree-preorder-traversal/

### 需求概述

给定一个树结构,其中每个节点都包含一个`Int`类型的值,以及对左右子节点的引用
要求使用前序遍历处理树结构,并用`IList<int>`类型输出结果
*前序遍历:对于一个树结构中的节点,首先访问节点本身,然后分别访问左子树和右子树*

### 计算逻辑与代码

#### 使用递归

对于一棵树(包括子树),首先访问根节点,然后分别遍历左右节点,结果全部输出到同一个数组中,即可达到前序遍历的效果

**评价:**
正常来说看到树相关的算法,第一想到的就是递归解法
递归本身效率比较高(仅需要付出函数调用的开销即可),而且符合抽象上的逻辑
唯一需要注意的是递归的层数,极端情况下可能出现栈溢出异常

#### 使用堆栈+循环

对于一棵树(包括子树),首先访问根节点,然后将右节点和左节点分别推入栈中
然后开启循环,当栈不为空时,弹出最顶层的节点,访问其值,然后查看此节点是否有子节点,如果有子节点,继续按照先右节点后左节点的顺序入栈
循环直到栈中所有节点都弹出即可
*由于题目要求前序遍历,应当按照根节点-左子节点-右子节点的顺序处理,所以入栈的时候需要先推入右子节点,然后再推入左子节点,出栈的时候也会对应地先弹出左子节点进行处理*

**评价:**
使用堆栈的解法相比于递归解法没有那么直观,而且效率也不一定更高,但是不会出现程序栈溢出的异常
很多时候面试官会更喜欢用这种方式考察代码,主要是考察面试人思维能否快速转换

### 代码

`/src/Leetcode/Binary_Tree_Preorder_Traversal_144.cs`

### 测试用例

`/src/LeetcodeTest/BinaryTreePreorderTraversalTest.cs`

1. 根节点为空
2. 树结构仅包含根节点
3. 一个二层的树,包含少数几个节点(左右都有)
4. 一个三层的树,仅包含左/右子节点
5. 一个完全二叉树
